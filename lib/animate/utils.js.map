{"version":3,"file":"utils.js","sources":["../../src/animate/utils.ts"],"sourcesContent":["import type { DrawCommands } from './Graphics';\nimport type { TweenProps, KeyframeData, TweenData, TweenablePropNames } from './Tween';\nimport type { DisplayObject } from '@pixi/display';\nimport type { Renderer } from '@pixi/core';\nimport type { Prepare } from '@pixi/prepare';\nimport type { MovieClip } from './MovieClip';\n\n// If the movieclip plugin is installed\nlet _prepare: Prepare = null;\n\n/* eslint-disable @typescript-eslint/no-namespace, no-inner-declarations */\n// awkwardly named instead of the final export of 'utils' to avoid problems in .d.ts build tools.\nexport namespace utils\n{\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     */\n    export function hexToUint(hex: string): number\n    {\n        // Remove the hash\n        hex = hex.substr(1);\n\n        // Convert shortcolors fc9 to ffcc99\n        if (hex.length === 3)\n        {\n            hex = hex.replace(/([a-f0-9])/g, '$1$1');\n        }\n\n        return parseInt(hex, 16);\n    }\n\n    /**\n     * Fill frames with booleans of true (showing) and false (hidden).\n     * @param timeline -\n     * @param startFrame - The start frame when the timeline shows up\n     * @param duration - The length of showing\n     */\n    export function fillFrames(timeline: boolean[], startFrame: number, duration: number): void\n    {\n        // ensure that the timeline is long enough\n        const oldLength = timeline.length;\n\n        if (oldLength < startFrame + duration)\n        {\n            timeline.length = startFrame + duration;\n            // fill any gaps with false to denote that the child should be removed for a bit\n            if (oldLength < startFrame)\n            {\n                // if the browser has implemented the ES6 fill() function, use that\n                if (timeline.fill)\n                {\n                    timeline.fill(false, oldLength, startFrame);\n                }\n                else\n                {\n                    // if we can't use fill, then do a for loop to fill it\n                    for (let i = oldLength; i < startFrame; ++i)\n                    {\n                        timeline[i] = false;\n                    }\n                }\n            }\n        }\n        // if the browser has implemented the ES6 fill() function, use that\n        if (timeline.fill)\n        {\n            timeline.fill(true, startFrame, startFrame + duration);\n        }\n        else\n        {\n            const length = timeline.length;\n            // if we can't use fill, then do a for loop to fill it\n\n            for (let i = startFrame; i < length; ++i)\n            {\n                timeline[i] = true;\n            }\n        }\n    }\n\n    const keysMap: {[s: string]: keyof TweenProps} = {\n        X: 'x', // x position\n        Y: 'y', // y position\n        A: 'sx', // scale x\n        B: 'sy', // scale y\n        C: 'kx', // skew x\n        D: 'ky', // skew y\n        R: 'r', // rotation\n        L: 'a', // alpha\n        T: 't', // tint\n        F: 'c', // colorTransform\n        V: 'v', // visibility\n    };\n\n    /**\n     * Parse the value of the compressed keyframe.\n     * @param prop - The property key\n     * @param buffer - The contents\n     * @return The parsed value\n     */\n    function parseValue(prop: string, buffer: string): string | number | boolean | (string | number)[]\n    {\n        switch (prop)\n        {\n            // Color transforms are parsed as an array\n            case 'c':\n            {\n                const buff: (string | number)[] = buffer.split(',');\n\n                buff.forEach((val, i, buffer) =>\n                {\n                    buffer[i] = parseFloat(val as string);\n                });\n\n                return buff;\n            }\n            // Tint value should not be converted\n            // can be color uint or string\n            case 't':\n            {\n                return buffer;\n            }\n            // The visiblity parse as boolean\n            case 'v':\n            {\n                return !!parseInt(buffer, 10);\n            }\n            // Everything else parse a floats\n            default:\n            {\n                return parseFloat(buffer);\n            }\n        }\n    }\n\n    const tweenKeysMap: { [s: string]: keyof TweenData } = {\n        D: 'd', // duration\n        // E: 'e', // easing - disabled for manual handling\n        P: 'p', // props\n    };\n\n    /**\n     * Regex to test for a basic ease desccriptor\n     */\n    const basicEase = /(\\-?\\d*\\.?\\d*)([a-zA-Z]+)/;\n\n    /**\n     * Convert serialized tween from a serialized keyframe into TweenData\n     * `\"D20E25EaseIn;PX3Y5A1.2\"` to: `{ d: 20, e: { s: 25, n: \"EaseIn\" }, p: { x:3, y: 5, sx: 1.2 } }`\n     * @param tweenBuffer -\n     * @return Resulting TweenData\n     */\n    function parseTween(tweenBuffer: string): TweenData\n    {\n        const result: TweenData = { d: 0, p: {} };\n\n        let i = 0;\n        let buffer = '';\n        let handlingProps = false;\n        let prop: keyof TweenProps | keyof TweenData;\n\n        // tween format:\n        // D20E25EaseIn;PX3Y5A1.2\n\n        while (i <= tweenBuffer.length)\n        {\n            const c = tweenBuffer[i];\n\n            if (!handlingProps && (tweenKeysMap[prop] || tweenKeysMap[c]))\n            {\n                // handle potential active duration property, which is the only normal one\n                if (prop === 'd')\n                {\n                    (result.d as any) = parseValue(prop, buffer);\n                    prop = null;\n                }\n\n                // seeing the p property kicks us immediately into props mode\n                if (c === 'P')\n                {\n                    handlingProps = true;\n                    ++i;\n                }\n                else\n                {\n                    // only handles D, really\n                    prop = tweenKeysMap[c];\n                    ++i;\n                }\n                buffer = '';\n            }\n            // seeing easing means we need to read ahead to the end of the easing section\n            else if (c === 'E')\n            {\n                // search for the next space or end of the string to see where the tween ends\n                let index = tweenBuffer.indexOf(';', i);\n\n                // should never end early, but just in case we are somehow tweening 0 properties\n                if (index < 0)\n                {\n                    index = tweenBuffer.length;\n                }\n                const easeBuffer = tweenBuffer.substring(i + 1, index);\n\n                if (basicEase.test(easeBuffer))\n                {\n                    const [, strength, name] = basicEase.exec(easeBuffer);\n\n                    // if not yet handling props, apply ease to whole tween\n                    if (!handlingProps)\n                    {\n                        result.e = {\n                            s: parseFloat(strength),\n                            n: name,\n                        };\n                    }\n                    // apply ease to last property read\n                    else if (prop)\n                    {\n                        (result.p[prop as TweenablePropNames] as any) = parseValue(prop, buffer);\n                        if (!result.p.e)\n                        {\n                            result.p.e = {};\n                        }\n                        result.p.e[prop as TweenablePropNames] = {\n                            s: parseFloat(strength),\n                            n: name,\n                        };\n                        prop = null;\n                        buffer = '';\n                    }\n                }\n                else\n                {\n                    // TODO: encode some sort of function for a custom ease\n                }\n\n                i = index + 1;\n            }\n            // normal prop/buffer handling, like in the main deserializeKeyframes function\n            else if (keysMap[c])\n            {\n                if (prop)\n                {\n                    (result.p[prop as keyof TweenProps] as any) = parseValue(prop, buffer);\n                }\n                prop = keysMap[c];\n                buffer = '';\n                i++;\n            }\n            else if (!c)\n            {\n                if (prop)\n                {\n                    (result.p[prop as keyof TweenProps] as any) = parseValue(prop, buffer);\n                }\n                buffer = '';\n                prop = null;\n                i++;\n            }\n            else\n            {\n                buffer += c;\n                i++;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Convert serialized array into keyframes\n     * `\"0x100y100 1x150\"` to: `{ \"0\": {\"x\":100, \"y\": 100}, \"1\": {\"x\": 150} }`\n     * @param keyframes -\n     * @return Resulting keyframes\n     */\n    export function deserializeKeyframes(keyframes: string): {[s: number]: KeyframeData}\n    {\n        const result: {[s: number]: KeyframeData} = {};\n        let i = 0;\n\n        let buffer = '';\n        let isFrameStarted = false;\n        let prop: keyof TweenProps;\n        let frame: KeyframeData = {};\n\n        while (i <= keyframes.length)\n        {\n            const c = keyframes[i];\n\n            // if we found the name of a property\n            if (keysMap[c])\n            {\n                // start a new frame if we need to\n                if (!isFrameStarted)\n                {\n                    isFrameStarted = true;\n                    result[buffer as any] = frame;\n                }\n                // finish a previous prop if one is running\n                if (prop)\n                {\n                    (frame[prop] as any) = parseValue(prop, buffer);\n                }\n                // save the new prop that we are now handling\n                prop = keysMap[c];\n                // reset buffer (because we did the previous prop if we had to)\n                buffer = '';\n                i++;\n            }\n            // contains a tween\n            else if (c === 'W')\n            {\n                // start a new frame if we need to\n                if (!isFrameStarted)\n                {\n                    isFrameStarted = true;\n                    result[buffer as any] = frame;\n                }\n                // finish previous prop\n                if (prop)\n                {\n                    (frame[prop] as any) = parseValue(prop, buffer);\n                    buffer = '';\n                    prop = null;\n                }\n                // search for the next space or end of the string to see where the tween ends\n                let index = keyframes.indexOf(' ', i);\n\n                if (index < 0)\n                {\n                    index = keyframes.length;\n                }\n                // parse the tween section\n                frame.tw = parseTween(keyframes.substring(i + 1, index));\n                // skip past the tween section\n                i = index;\n            }\n            // finish existing prop & frame on end of string or space\n            else if (!c || c === ' ')\n            {\n                i++;\n                if (prop)\n                {\n                    (frame[prop] as any) = parseValue(prop, buffer);\n                }\n                buffer = '';\n                prop = null;\n                frame = {};\n                isFrameStarted = false;\n            }\n            // add to the buffer for the next parse\n            else\n            {\n                buffer += c;\n                i++;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Convert serialized shapes into draw commands for PIXI.Graphics.\n     * @param str -\n     */\n    export function deserializeShapes(str: string): DrawCommands[]\n    {\n        const result = [];\n        // each shape is a new line\n        const shapes = str.split('\\n');\n        const isCommand = /^[a-z]{1,2}$/;\n\n        for (let i = 0; i < shapes.length; i++)\n        {\n            const shape: DrawCommands = shapes[i].split(' '); // arguments are space separated\n\n            for (let j = 0; j < shape.length; j++)\n            {\n                // Convert all numbers to floats, ignore colors\n                const arg = shape[j] as string;\n\n                if (arg[0] !== '#' && !isCommand.test(arg))\n                {\n                    shape[j] = parseFloat(arg);\n                }\n            }\n            result.push(shape);\n        }\n\n        return result;\n    }\n\n    /**\n     * Add movie clips to the upload prepare.\n     * @param item - item To add to the queue\n     */\n    export function addMovieClips(item: any): boolean\n    {\n        if (item.isMovieClip)\n        {\n            const mc = item as MovieClip;\n\n            mc._timedChildTimelines.forEach((timeline) =>\n            {\n                const index = mc.children.indexOf(timeline.target);\n\n                if (index === -1)\n                {\n                    // eslint-disable-next-line no-unused-expressions\n                    _prepare?.add(timeline.target);\n                }\n            });\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU.\n     * @param renderer - Render to upload to\n     * @param clip - MovieClip to upload\n     * @param done - When complete\n     */\n    export function upload(renderer: Renderer, displayObject: DisplayObject, done: () => void): void\n    {\n        if (!_prepare)\n        {\n            _prepare = renderer.plugins.prepare;\n            _prepare.registerFindHook(addMovieClips);\n        }\n        // eslint-disable-next-line no-unused-expressions\n        _prepare?.upload(displayObject).then(done);\n    }\n}\n"],"names":["utils","buffer"],"mappings":"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"}